// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: bookings_users.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createBookingUser = `-- name: CreateBookingUser :exec
INSERT INTO bookings_users (booking_id, user_id, is_primary)
VALUES ($1, $2, $3)
`

type CreateBookingUserParams struct {
	BookingID pgtype.UUID `json:"booking_id"`
	UserID    pgtype.UUID `json:"user_id"`
	IsPrimary bool        `json:"is_primary"`
}

func (q *Queries) CreateBookingUser(ctx context.Context, arg CreateBookingUserParams) error {
	_, err := q.db.Exec(ctx, createBookingUser, arg.BookingID, arg.UserID, arg.IsPrimary)
	return err
}

const deleteBookingUser = `-- name: DeleteBookingUser :exec
DELETE FROM bookings_users
WHERE booking_id = $1 AND user_id = $2
`

type DeleteBookingUserParams struct {
	BookingID pgtype.UUID `json:"booking_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

func (q *Queries) DeleteBookingUser(ctx context.Context, arg DeleteBookingUserParams) error {
	_, err := q.db.Exec(ctx, deleteBookingUser, arg.BookingID, arg.UserID)
	return err
}

const deleteBookingUsers = `-- name: DeleteBookingUsers :exec
DELETE FROM bookings_users
WHERE booking_id = $1
`

func (q *Queries) DeleteBookingUsers(ctx context.Context, bookingID pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteBookingUsers, bookingID)
	return err
}

const getBookingUsers = `-- name: GetBookingUsers :many
SELECT u.id, u.email, u.password_hash, u.full_name, u.phone, u.created_at, u.updated_at 
FROM users u
JOIN bookings_users bu ON u.id = bu.user_id
WHERE bu.booking_id = $1
ORDER BY bu.is_primary DESC, u.created_at ASC
`

func (q *Queries) GetBookingUsers(ctx context.Context, bookingID pgtype.UUID) ([]User, error) {
	rows, err := q.db.Query(ctx, getBookingUsers, bookingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []User
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.FullName,
			&i.Phone,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPrimaryBookingUser = `-- name: GetPrimaryBookingUser :one
SELECT u.id, u.email, u.password_hash, u.full_name, u.phone, u.created_at, u.updated_at 
FROM users u
JOIN bookings_users bu ON u.id = bu.user_id
WHERE bu.booking_id = $1 AND bu.is_primary = TRUE
LIMIT 1
`

func (q *Queries) GetPrimaryBookingUser(ctx context.Context, bookingID pgtype.UUID) (User, error) {
	row := q.db.QueryRow(ctx, getPrimaryBookingUser, bookingID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.FullName,
		&i.Phone,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const setPrimaryBookingUser = `-- name: SetPrimaryBookingUser :exec
UPDATE bookings_users
SET is_primary = CASE WHEN user_id = $2 THEN TRUE ELSE FALSE END
WHERE booking_id = $1
`

type SetPrimaryBookingUserParams struct {
	BookingID pgtype.UUID `json:"booking_id"`
	UserID    pgtype.UUID `json:"user_id"`
}

func (q *Queries) SetPrimaryBookingUser(ctx context.Context, arg SetPrimaryBookingUserParams) error {
	_, err := q.db.Exec(ctx, setPrimaryBookingUser, arg.BookingID, arg.UserID)
	return err
}
