// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: availability_slots.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createAvailabilitySlot = `-- name: CreateAvailabilitySlot :one
INSERT INTO availability_slots (service_id, day_of_week, start_time, end_time, max_bookings, is_active, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, service_id, day_of_week, start_time, end_time, max_bookings, is_active, created_at, updated_at
`

type CreateAvailabilitySlotParams struct {
	ServiceID   pgtype.UUID        `json:"service_id"`
	DayOfWeek   int32              `json:"day_of_week"`
	StartTime   pgtype.Time        `json:"start_time"`
	EndTime     pgtype.Time        `json:"end_time"`
	MaxBookings int32              `json:"max_bookings"`
	IsActive    bool               `json:"is_active"`
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreateAvailabilitySlot(ctx context.Context, arg CreateAvailabilitySlotParams) (AvailabilitySlot, error) {
	row := q.db.QueryRow(ctx, createAvailabilitySlot,
		arg.ServiceID,
		arg.DayOfWeek,
		arg.StartTime,
		arg.EndTime,
		arg.MaxBookings,
		arg.IsActive,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i AvailabilitySlot
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.MaxBookings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deleteAvailabilitySlot = `-- name: DeleteAvailabilitySlot :exec
DELETE FROM availability_slots
WHERE id = $1
`

func (q *Queries) DeleteAvailabilitySlot(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deleteAvailabilitySlot, id)
	return err
}

const getAvailabilitySlot = `-- name: GetAvailabilitySlot :one
SELECT id, service_id, day_of_week, start_time, end_time, max_bookings, is_active, created_at, updated_at FROM availability_slots
WHERE id = $1
`

func (q *Queries) GetAvailabilitySlot(ctx context.Context, id pgtype.UUID) (AvailabilitySlot, error) {
	row := q.db.QueryRow(ctx, getAvailabilitySlot, id)
	var i AvailabilitySlot
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.MaxBookings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getAvailabilitySlotForDayAndTime = `-- name: GetAvailabilitySlotForDayAndTime :one
SELECT id, service_id, day_of_week, start_time, end_time, max_bookings, is_active, created_at, updated_at FROM availability_slots
WHERE service_id = $1 AND day_of_week = $2 AND is_active = $3
LIMIT 1
`

type GetAvailabilitySlotForDayAndTimeParams struct {
	ServiceID pgtype.UUID `json:"service_id"`
	DayOfWeek int32       `json:"day_of_week"`
	IsActive  bool        `json:"is_active"`
}

func (q *Queries) GetAvailabilitySlotForDayAndTime(ctx context.Context, arg GetAvailabilitySlotForDayAndTimeParams) (AvailabilitySlot, error) {
	row := q.db.QueryRow(ctx, getAvailabilitySlotForDayAndTime, arg.ServiceID, arg.DayOfWeek, arg.IsActive)
	var i AvailabilitySlot
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.MaxBookings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const listAllAvailabilitySlots = `-- name: ListAllAvailabilitySlots :many
SELECT id, service_id, day_of_week, start_time, end_time, max_bookings, is_active, created_at, updated_at FROM availability_slots
ORDER BY service_id ASC, day_of_week ASC, start_time ASC
`

func (q *Queries) ListAllAvailabilitySlots(ctx context.Context) ([]AvailabilitySlot, error) {
	rows, err := q.db.Query(ctx, listAllAvailabilitySlots)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AvailabilitySlot
	for rows.Next() {
		var i AvailabilitySlot
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.MaxBookings,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listAvailabilitySlotsByService = `-- name: ListAvailabilitySlotsByService :many
SELECT id, service_id, day_of_week, start_time, end_time, max_bookings, is_active, created_at, updated_at FROM availability_slots
WHERE service_id = $1 AND is_active = $2
ORDER BY day_of_week ASC, start_time ASC
`

type ListAvailabilitySlotsByServiceParams struct {
	ServiceID pgtype.UUID `json:"service_id"`
	IsActive  bool        `json:"is_active"`
}

func (q *Queries) ListAvailabilitySlotsByService(ctx context.Context, arg ListAvailabilitySlotsByServiceParams) ([]AvailabilitySlot, error) {
	rows, err := q.db.Query(ctx, listAvailabilitySlotsByService, arg.ServiceID, arg.IsActive)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []AvailabilitySlot
	for rows.Next() {
		var i AvailabilitySlot
		if err := rows.Scan(
			&i.ID,
			&i.ServiceID,
			&i.DayOfWeek,
			&i.StartTime,
			&i.EndTime,
			&i.MaxBookings,
			&i.IsActive,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateAvailabilitySlot = `-- name: UpdateAvailabilitySlot :one
UPDATE availability_slots
SET start_time = COALESCE($3, start_time),
    end_time = COALESCE($4, end_time),
    max_bookings = COALESCE($5, max_bookings),
    is_active = COALESCE($6, is_active),
    updated_at = $2
WHERE id = $1
RETURNING id, service_id, day_of_week, start_time, end_time, max_bookings, is_active, created_at, updated_at
`

type UpdateAvailabilitySlotParams struct {
	ID          pgtype.UUID        `json:"id"`
	UpdatedAt   pgtype.Timestamptz `json:"updated_at"`
	StartTime   pgtype.Time        `json:"start_time"`
	EndTime     pgtype.Time        `json:"end_time"`
	MaxBookings pgtype.Int4        `json:"max_bookings"`
	IsActive    pgtype.Bool        `json:"is_active"`
}

func (q *Queries) UpdateAvailabilitySlot(ctx context.Context, arg UpdateAvailabilitySlotParams) (AvailabilitySlot, error) {
	row := q.db.QueryRow(ctx, updateAvailabilitySlot,
		arg.ID,
		arg.UpdatedAt,
		arg.StartTime,
		arg.EndTime,
		arg.MaxBookings,
		arg.IsActive,
	)
	var i AvailabilitySlot
	err := row.Scan(
		&i.ID,
		&i.ServiceID,
		&i.DayOfWeek,
		&i.StartTime,
		&i.EndTime,
		&i.MaxBookings,
		&i.IsActive,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
