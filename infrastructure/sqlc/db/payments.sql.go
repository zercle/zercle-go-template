// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: payments.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const confirmPayment = `-- name: ConfirmPayment :one
UPDATE payments
SET status = 'completed', paid_at = $2, updated_at = $3
WHERE id = $1
RETURNING id, booking_id, amount, status, payment_method, transaction_id, paid_at, refunded_at, created_at, updated_at
`

type ConfirmPaymentParams struct {
	ID        pgtype.UUID        `json:"id"`
	PaidAt    pgtype.Timestamptz `json:"paid_at"`
	UpdatedAt pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) ConfirmPayment(ctx context.Context, arg ConfirmPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, confirmPayment, arg.ID, arg.PaidAt, arg.UpdatedAt)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.Amount,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.PaidAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const createPayment = `-- name: CreatePayment :one
INSERT INTO payments (id, booking_id, amount, status, payment_method, transaction_id, created_at, updated_at)
VALUES ($1, $2, $3, $4, $5, $6, $7, $8)
RETURNING id, booking_id, amount, status, payment_method, transaction_id, paid_at, refunded_at, created_at, updated_at
`

type CreatePaymentParams struct {
	ID            pgtype.UUID        `json:"id"`
	BookingID     pgtype.UUID        `json:"booking_id"`
	Amount        pgtype.Numeric     `json:"amount"`
	Status        string             `json:"status"`
	PaymentMethod pgtype.Text        `json:"payment_method"`
	TransactionID pgtype.Text        `json:"transaction_id"`
	CreatedAt     pgtype.Timestamptz `json:"created_at"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) CreatePayment(ctx context.Context, arg CreatePaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, createPayment,
		arg.ID,
		arg.BookingID,
		arg.Amount,
		arg.Status,
		arg.PaymentMethod,
		arg.TransactionID,
		arg.CreatedAt,
		arg.UpdatedAt,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.Amount,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.PaidAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const deletePayment = `-- name: DeletePayment :exec
DELETE FROM payments
WHERE id = $1
`

func (q *Queries) DeletePayment(ctx context.Context, id pgtype.UUID) error {
	_, err := q.db.Exec(ctx, deletePayment, id)
	return err
}

const getPayment = `-- name: GetPayment :one
SELECT id, booking_id, amount, status, payment_method, transaction_id, paid_at, refunded_at, created_at, updated_at FROM payments
WHERE id = $1
`

func (q *Queries) GetPayment(ctx context.Context, id pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPayment, id)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.Amount,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.PaidAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByBooking = `-- name: GetPaymentByBooking :one
SELECT id, booking_id, amount, status, payment_method, transaction_id, paid_at, refunded_at, created_at, updated_at FROM payments
WHERE booking_id = $1
ORDER BY created_at DESC
LIMIT 1
`

func (q *Queries) GetPaymentByBooking(ctx context.Context, bookingID pgtype.UUID) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByBooking, bookingID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.Amount,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.PaidAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentByTransactionId = `-- name: GetPaymentByTransactionId :one
SELECT id, booking_id, amount, status, payment_method, transaction_id, paid_at, refunded_at, created_at, updated_at FROM payments
WHERE transaction_id = $1
LIMIT 1
`

func (q *Queries) GetPaymentByTransactionId(ctx context.Context, transactionID pgtype.Text) (Payment, error) {
	row := q.db.QueryRow(ctx, getPaymentByTransactionId, transactionID)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.Amount,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.PaidAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const getPaymentStats = `-- name: GetPaymentStats :one
SELECT 
    COUNT(*) as total_payments,
    COUNT(*) FILTER (WHERE status = 'pending') as pending_count,
    COUNT(*) FILTER (WHERE status = 'completed') as completed_count,
    COUNT(*) FILTER (WHERE status = 'refunded') as refunded_count,
    COALESCE(SUM(amount) FILTER (WHERE status = 'completed'), 0) as total_revenue,
    COALESCE(SUM(amount) FILTER (WHERE status = 'refunded'), 0) as total_refunds
FROM payments
WHERE created_at >= $1 AND created_at <= $2
`

type GetPaymentStatsParams struct {
	CreatedAt   pgtype.Timestamptz `json:"created_at"`
	CreatedAt_2 pgtype.Timestamptz `json:"created_at_2"`
}

type GetPaymentStatsRow struct {
	TotalPayments  int64       `json:"total_payments"`
	PendingCount   int64       `json:"pending_count"`
	CompletedCount int64       `json:"completed_count"`
	RefundedCount  int64       `json:"refunded_count"`
	TotalRevenue   interface{} `json:"total_revenue"`
	TotalRefunds   interface{} `json:"total_refunds"`
}

func (q *Queries) GetPaymentStats(ctx context.Context, arg GetPaymentStatsParams) (GetPaymentStatsRow, error) {
	row := q.db.QueryRow(ctx, getPaymentStats, arg.CreatedAt, arg.CreatedAt_2)
	var i GetPaymentStatsRow
	err := row.Scan(
		&i.TotalPayments,
		&i.PendingCount,
		&i.CompletedCount,
		&i.RefundedCount,
		&i.TotalRevenue,
		&i.TotalRefunds,
	)
	return i, err
}

const listPaymentsByBooking = `-- name: ListPaymentsByBooking :many
SELECT id, booking_id, amount, status, payment_method, transaction_id, paid_at, refunded_at, created_at, updated_at FROM payments
WHERE booking_id = $1
ORDER BY created_at DESC
`

func (q *Queries) ListPaymentsByBooking(ctx context.Context, bookingID pgtype.UUID) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPaymentsByBooking, bookingID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.Amount,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.PaidAt,
			&i.RefundedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listPaymentsByStatus = `-- name: ListPaymentsByStatus :many
SELECT id, booking_id, amount, status, payment_method, transaction_id, paid_at, refunded_at, created_at, updated_at FROM payments
WHERE status = $1
ORDER BY created_at DESC
LIMIT $2 OFFSET $3
`

type ListPaymentsByStatusParams struct {
	Status string `json:"status"`
	Limit  int32  `json:"limit"`
	Offset int32  `json:"offset"`
}

func (q *Queries) ListPaymentsByStatus(ctx context.Context, arg ListPaymentsByStatusParams) ([]Payment, error) {
	rows, err := q.db.Query(ctx, listPaymentsByStatus, arg.Status, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Payment
	for rows.Next() {
		var i Payment
		if err := rows.Scan(
			&i.ID,
			&i.BookingID,
			&i.Amount,
			&i.Status,
			&i.PaymentMethod,
			&i.TransactionID,
			&i.PaidAt,
			&i.RefundedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const refundPayment = `-- name: RefundPayment :one
UPDATE payments
SET status = 'refunded', refunded_at = $2, updated_at = $3
WHERE id = $1
RETURNING id, booking_id, amount, status, payment_method, transaction_id, paid_at, refunded_at, created_at, updated_at
`

type RefundPaymentParams struct {
	ID         pgtype.UUID        `json:"id"`
	RefundedAt pgtype.Timestamptz `json:"refunded_at"`
	UpdatedAt  pgtype.Timestamptz `json:"updated_at"`
}

func (q *Queries) RefundPayment(ctx context.Context, arg RefundPaymentParams) (Payment, error) {
	row := q.db.QueryRow(ctx, refundPayment, arg.ID, arg.RefundedAt, arg.UpdatedAt)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.Amount,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.PaidAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}

const updatePaymentStatus = `-- name: UpdatePaymentStatus :one
UPDATE payments
SET status = $2, transaction_id = COALESCE($4, transaction_id), updated_at = $3
WHERE id = $1
RETURNING id, booking_id, amount, status, payment_method, transaction_id, paid_at, refunded_at, created_at, updated_at
`

type UpdatePaymentStatusParams struct {
	ID            pgtype.UUID        `json:"id"`
	Status        string             `json:"status"`
	UpdatedAt     pgtype.Timestamptz `json:"updated_at"`
	TransactionID pgtype.Text        `json:"transaction_id"`
}

func (q *Queries) UpdatePaymentStatus(ctx context.Context, arg UpdatePaymentStatusParams) (Payment, error) {
	row := q.db.QueryRow(ctx, updatePaymentStatus,
		arg.ID,
		arg.Status,
		arg.UpdatedAt,
		arg.TransactionID,
	)
	var i Payment
	err := row.Scan(
		&i.ID,
		&i.BookingID,
		&i.Amount,
		&i.Status,
		&i.PaymentMethod,
		&i.TransactionID,
		&i.PaidAt,
		&i.RefundedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
	)
	return i, err
}
